<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Isometric Grid</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-tertiary: #0f3460;
      --accent: #e94560;
      --accent-hover: #ff6b6b;
      --text-primary: #eee;
      --text-secondary: #aaa;
      --border: #333;
      --floor-1: #4a6fa5;
      --floor-2: #5c8acd;
      --floor-3: #6b9de0;
      --wall-dark: #2d3a4f;
      --wall-light: #4a5568;
    }

    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      height: 100vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .toolbar-group {
      display: flex;
      align-items: center;
      gap: 4px;
      padding-right: 8px;
      border-right: 1px solid var(--border);
    }

    .toolbar-group:last-child {
      border-right: none;
    }

    .toolbar-label {
      font-size: 11px;
      color: var(--text-secondary);
      margin-right: 4px;
    }

    .btn {
      padding: 6px 10px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .btn:hover {
      background: var(--accent);
    }

    .btn.active {
      background: var(--accent);
      border-color: var(--accent-hover);
    }

    .btn-icon {
      padding: 6px 8px;
      font-size: 14px;
    }

    select {
      padding: 5px 8px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 12px;
      cursor: pointer;
    }

    input[type="number"] {
      width: 50px;
      padding: 5px 6px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 12px;
    }

    .canvas-container {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
    }

    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      padding: 4px 12px;
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      font-size: 11px;
      color: var(--text-secondary);
    }

    .tile-palette {
      position: absolute;
      right: 10px;
      top: 10px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      display: none;
      max-height: 300px;
      overflow-y: auto;
    }

    .tile-palette.visible {
      display: block;
    }

    .palette-section {
      margin-bottom: 8px;
    }

    .palette-title {
      font-size: 10px;
      color: var(--text-secondary);
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    .palette-grid {
      display: grid;
      grid-template-columns: repeat(4, 32px);
      gap: 4px;
    }

    .palette-tile {
      width: 32px;
      height: 32px;
      border: 2px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .palette-tile:hover {
      border-color: var(--accent-hover);
      transform: scale(1.1);
    }

    .palette-tile.selected {
      border-color: var(--accent);
      box-shadow: 0 0 8px var(--accent);
    }

    .settings-panel {
      position: absolute;
      left: 10px;
      top: 10px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      display: none;
      width: 200px;
    }

    .settings-panel.visible {
      display: block;
    }

    .settings-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .settings-row label {
      font-size: 12px;
    }

    .character-info {
      position: absolute;
      background: var(--bg-secondary);
      border: 1px solid var(--accent);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 11px;
      pointer-events: none;
      display: none;
      z-index: 100;
    }

    .character-info.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div class="toolbar">
    <div class="toolbar-group">
      <span class="toolbar-label">Mode:</span>
      <button class="btn active" id="btnEdit" title="Edit Mode">‚úèÔ∏è Edit</button>
      <button class="btn" id="btnGame" title="Game Mode">üéÆ Game</button>
    </div>

    <div class="toolbar-group">
      <span class="toolbar-label">Tool:</span>
      <button class="btn btn-icon active" id="toolSelect" title="Select">üñ±Ô∏è</button>
      <button class="btn btn-icon" id="toolFloor" title="Place Floor">üü¶</button>
      <button class="btn btn-icon" id="toolWall" title="Place Wall">üß±</button>
      <button class="btn btn-icon" id="toolFurniture" title="Place Furniture">ü™ë</button>
      <button class="btn btn-icon" id="toolErase" title="Erase">üóëÔ∏è</button>
      <button class="btn btn-icon" id="toolElevation" title="Change Elevation">üìê</button>
    </div>

    <div class="toolbar-group">
      <span class="toolbar-label">Grid:</span>
      <input type="number" id="gridWidth" value="10" min="5" max="50" title="Grid Width">
      <span style="color: var(--text-secondary)">√ó</span>
      <input type="number" id="gridHeight" value="10" min="5" max="50" title="Grid Height">
      <button class="btn" id="btnApplyGrid">Apply</button>
    </div>

    <div class="toolbar-group">
      <span class="toolbar-label">Chars:</span>
      <button class="btn btn-icon" id="btnAddChar" title="Add Test Character">üë§+</button>
      <button class="btn btn-icon" id="btnLoadChar" title="Load Character (from Character Widget)">üì•</button>
      <button class="btn btn-icon" id="btnClearChars" title="Remove All Characters">üë•‚úñ</button>
    </div>

    <div class="toolbar-group">
      <button class="btn btn-icon" id="btnPalette" title="Tile Palette">üé®</button>
      <button class="btn btn-icon" id="btnSettings" title="Settings">‚öôÔ∏è</button>
      <button class="btn btn-icon" id="btnClear" title="Clear Map">üóëÔ∏è</button>
      <button class="btn btn-icon" id="btnExport" title="Export Map">üíæ</button>
    </div>
  </div>

  <div class="canvas-container">
    <canvas id="gameCanvas"></canvas>

    <div class="tile-palette" id="tilePalette">
      <div class="palette-section">
        <div class="palette-title">Floors</div>
        <div class="palette-grid" id="floorPalette"></div>
      </div>
      <div class="palette-section">
        <div class="palette-title">Walls</div>
        <div class="palette-grid" id="wallPalette"></div>
      </div>
      <div class="palette-section">
        <div class="palette-title">Furniture</div>
        <div class="palette-grid" id="furniturePalette"></div>
      </div>
    </div>

    <div class="settings-panel" id="settingsPanel">
      <div class="settings-row">
        <label>Tile Width:</label>
        <input type="number" id="tileWidth" value="64" min="32" max="128">
      </div>
      <div class="settings-row">
        <label>Tile Height:</label>
        <input type="number" id="tileHeight" value="32" min="16" max="64">
      </div>
      <div class="settings-row">
        <label>Wall Height:</label>
        <input type="number" id="wallHeight" value="48" min="24" max="96">
      </div>
      <div class="settings-row">
        <label>Show Grid:</label>
        <input type="checkbox" id="showGrid" checked>
      </div>
      <div class="settings-row">
        <label>Animate Water:</label>
        <input type="checkbox" id="animateWater" checked>
      </div>
      <button class="btn" id="btnApplySettings" style="width: 100%; margin-top: 8px;">Apply</button>
    </div>

    <div class="character-info" id="characterInfo"></div>
  </div>

  <div class="status-bar">
    <span id="statusLeft">Mode: Edit | Tool: Select</span>
    <span id="statusCenter">Tile: -</span>
    <span id="statusRight">Characters: 0</span>
  </div>

  <script>
    // ===== STATE =====
    const state = {
      mode: 'edit', // 'edit' | 'game'
      tool: 'select',
      selectedTile: { type: 'floor', variant: 0 },
      gridWidth: 10,
      gridHeight: 10,
      tileWidth: 64,
      tileHeight: 32,
      wallHeight: 48,
      showGrid: true,
      animateWater: true,

      // Map data
      map: [], // 2D array of tiles
      characters: new Map(),

      // Camera
      camera: { x: 0, y: 0, zoom: 1 },
      isDragging: false,
      dragStart: { x: 0, y: 0 },

      // Selection
      selectedCharacter: null,
      hoveredTile: null,

      // Pathfinding
      currentPath: [],
      walkingCharacter: null
    };

    // ===== TILE DEFINITIONS =====
    const tileTypes = {
      floors: [
        { id: 0, name: 'Grass', colors: ['#4a7c59', '#5a8c69', '#3a6c49'] },
        { id: 1, name: 'Wood', colors: ['#8b6914', '#9b7924', '#7b5904'] },
        { id: 2, name: 'Carpet Blue', colors: ['#4a6fa5', '#5a7fb5', '#3a5f95'] },
        { id: 3, name: 'Carpet Red', colors: ['#a54a4a', '#b55a5a', '#953a3a'] },
        { id: 4, name: 'Stone', colors: ['#6b6b6b', '#7b7b7b', '#5b5b5b'] },
        { id: 5, name: 'Water', colors: ['#4a8fa5', '#5a9fb5', '#3a7f95'], animated: true },
        { id: 6, name: 'Sand', colors: ['#c9b97a', '#d9c98a', '#b9a96a'] },
        { id: 7, name: 'Tile White', colors: ['#e8e8e8', '#f8f8f8', '#d8d8d8'] }
      ],
      walls: [
        { id: 0, name: 'Brick', colors: ['#8b4513', '#a05a23', '#753d0f'] },
        { id: 1, name: 'Stone', colors: ['#555555', '#656565', '#454545'] },
        { id: 2, name: 'Wood', colors: ['#654321', '#755331', '#553311'] },
        { id: 3, name: 'White', colors: ['#cccccc', '#dddddd', '#bbbbbb'] },
        { id: 4, name: 'Glass', colors: ['rgba(150,200,255,0.5)', 'rgba(170,220,255,0.5)', 'rgba(130,180,235,0.5)'] }
      ],
      furniture: [
        { id: 0, name: 'Chair', icon: 'ü™ë', size: { w: 1, h: 1 } },
        { id: 1, name: 'Table', icon: 'ü™µ', size: { w: 2, h: 1 } },
        { id: 2, name: 'Sofa', icon: 'üõãÔ∏è', size: { w: 2, h: 1 } },
        { id: 3, name: 'Plant', icon: 'üå±', size: { w: 1, h: 1 } },
        { id: 4, name: 'Lamp', icon: 'üí°', size: { w: 1, h: 1 } },
        { id: 5, name: 'Bed', icon: 'üõèÔ∏è', size: { w: 2, h: 2 } },
        { id: 6, name: 'TV', icon: 'üì∫', size: { w: 2, h: 1 } },
        { id: 7, name: 'Bookshelf', icon: 'üìö', size: { w: 1, h: 1 } }
      ]
    };

    // ===== CANVAS SETUP =====
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;

      // Center the map
      state.camera.x = canvas.width / 2;
      state.camera.y = 100;

      render();
    }

    // ===== ISOMETRIC MATH =====
    function cartToIso(x, y) {
      return {
        x: (x - y) * (state.tileWidth / 2),
        y: (x + y) * (state.tileHeight / 2)
      };
    }

    function isoToCart(isoX, isoY) {
      const x = (isoX / (state.tileWidth / 2) + isoY / (state.tileHeight / 2)) / 2;
      const y = (isoY / (state.tileHeight / 2) - isoX / (state.tileWidth / 2)) / 2;
      return { x: Math.floor(x), y: Math.floor(y) };
    }

    function screenToWorld(screenX, screenY) {
      const worldX = (screenX - state.camera.x) / state.camera.zoom;
      const worldY = (screenY - state.camera.y) / state.camera.zoom;
      return isoToCart(worldX, worldY);
    }

    function worldToScreen(x, y, elevation = 0) {
      const iso = cartToIso(x, y);
      return {
        x: state.camera.x + iso.x * state.camera.zoom,
        y: state.camera.y + (iso.y - elevation * state.tileHeight) * state.camera.zoom
      };
    }

    // ===== MAP INITIALIZATION =====
    function initMap() {
      state.map = [];
      for (let y = 0; y < state.gridHeight; y++) {
        state.map[y] = [];
        for (let x = 0; x < state.gridWidth; x++) {
          state.map[y][x] = {
            floor: { type: 0, elevation: 0 },
            wall: null,
            furniture: null,
            walkable: true
          };
        }
      }
    }

    // ===== RENDERING =====
    function drawIsometricTile(x, y, colors, elevation = 0) {
      const screen = worldToScreen(x, y, elevation);
      const w = state.tileWidth * state.camera.zoom / 2;
      const h = state.tileHeight * state.camera.zoom / 2;

      ctx.beginPath();
      ctx.moveTo(screen.x, screen.y - h);
      ctx.lineTo(screen.x + w, screen.y);
      ctx.lineTo(screen.x, screen.y + h);
      ctx.lineTo(screen.x - w, screen.y);
      ctx.closePath();

      ctx.fillStyle = colors[0];
      ctx.fill();
      ctx.strokeStyle = colors[2];
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    function drawWall(x, y, wallType, elevation = 0) {
      const colors = tileTypes.walls[wallType].colors;
      const screen = worldToScreen(x, y, elevation);
      const w = state.tileWidth * state.camera.zoom / 2;
      const h = state.tileHeight * state.camera.zoom / 2;
      const wallH = state.wallHeight * state.camera.zoom;

      // Left face
      ctx.beginPath();
      ctx.moveTo(screen.x - w, screen.y);
      ctx.lineTo(screen.x, screen.y + h);
      ctx.lineTo(screen.x, screen.y + h - wallH);
      ctx.lineTo(screen.x - w, screen.y - wallH);
      ctx.closePath();
      ctx.fillStyle = colors[1];
      ctx.fill();
      ctx.strokeStyle = colors[2];
      ctx.stroke();

      // Right face
      ctx.beginPath();
      ctx.moveTo(screen.x, screen.y + h);
      ctx.lineTo(screen.x + w, screen.y);
      ctx.lineTo(screen.x + w, screen.y - wallH);
      ctx.lineTo(screen.x, screen.y + h - wallH);
      ctx.closePath();
      ctx.fillStyle = colors[0];
      ctx.fill();
      ctx.strokeStyle = colors[2];
      ctx.stroke();

      // Top face
      ctx.beginPath();
      ctx.moveTo(screen.x, screen.y - h - wallH + h);
      ctx.lineTo(screen.x + w, screen.y - wallH);
      ctx.lineTo(screen.x, screen.y + h - wallH);
      ctx.lineTo(screen.x - w, screen.y - wallH);
      ctx.closePath();
      ctx.fillStyle = colors[0];
      ctx.fill();
      ctx.strokeStyle = colors[2];
      ctx.stroke();
    }

    function drawFurniture(x, y, furnitureType, elevation = 0) {
      const furniture = tileTypes.furniture[furnitureType];
      const screen = worldToScreen(x, y, elevation);

      ctx.font = `${24 * state.camera.zoom}px Arial`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(furniture.icon, screen.x, screen.y - 10 * state.camera.zoom);
    }

    function drawCharacter(character) {
      const screen = worldToScreen(character.x, character.y, character.elevation || 0);

      // Draw shadow
      ctx.beginPath();
      ctx.ellipse(screen.x, screen.y + 5 * state.camera.zoom,
                  15 * state.camera.zoom, 8 * state.camera.zoom, 0, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fill();

      // Draw character body
      const bodyHeight = 40 * state.camera.zoom;
      const bodyWidth = 20 * state.camera.zoom;

      // Body
      ctx.fillStyle = character.color || '#4a90d9';
      ctx.beginPath();
      ctx.ellipse(screen.x, screen.y - bodyHeight/2,
                  bodyWidth/2, bodyHeight/2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Head
      ctx.fillStyle = character.skinColor || '#ffcc99';
      ctx.beginPath();
      ctx.arc(screen.x, screen.y - bodyHeight - 5 * state.camera.zoom,
              12 * state.camera.zoom, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Direction indicator
      if (character.direction) {
        const dirs = {
          'n': { dx: 0, dy: -1 },
          's': { dx: 0, dy: 1 },
          'e': { dx: 1, dy: 0 },
          'w': { dx: -1, dy: 0 },
          'ne': { dx: 1, dy: -1 },
          'nw': { dx: -1, dy: -1 },
          'se': { dx: 1, dy: 1 },
          'sw': { dx: -1, dy: 1 }
        };
        const dir = dirs[character.direction] || dirs['s'];
        ctx.fillStyle = '#333';
        ctx.beginPath();
        ctx.arc(screen.x + dir.dx * 5 * state.camera.zoom,
                screen.y - bodyHeight - 5 * state.camera.zoom + dir.dy * 3 * state.camera.zoom,
                3 * state.camera.zoom, 0, Math.PI * 2);
        ctx.fill();
      }

      // Name tag
      if (character.name) {
        ctx.font = `${10 * state.camera.zoom}px Arial`;
        ctx.textAlign = 'center';
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        const textWidth = ctx.measureText(character.name).width;
        ctx.fillRect(screen.x - textWidth/2 - 4, screen.y - bodyHeight - 30 * state.camera.zoom,
                     textWidth + 8, 14 * state.camera.zoom);
        ctx.fillStyle = '#fff';
        ctx.fillText(character.name, screen.x, screen.y - bodyHeight - 22 * state.camera.zoom);
      }

      // Selection indicator
      if (state.selectedCharacter === character.id) {
        ctx.strokeStyle = '#e94560';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.ellipse(screen.x, screen.y,
                    25 * state.camera.zoom, 12 * state.camera.zoom, 0, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    function drawPath() {
      if (state.currentPath.length < 2) return;

      ctx.strokeStyle = 'rgba(233, 69, 96, 0.5)';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();

      for (let i = 0; i < state.currentPath.length; i++) {
        const screen = worldToScreen(state.currentPath[i].x, state.currentPath[i].y);
        if (i === 0) {
          ctx.moveTo(screen.x, screen.y);
        } else {
          ctx.lineTo(screen.x, screen.y);
        }
      }

      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawHoverHighlight() {
      if (!state.hoveredTile) return;

      const { x, y } = state.hoveredTile;
      if (x < 0 || x >= state.gridWidth || y < 0 || y >= state.gridHeight) return;

      const tile = state.map[y]?.[x];
      const elevation = tile?.floor?.elevation || 0;
      const screen = worldToScreen(x, y, elevation);
      const w = state.tileWidth * state.camera.zoom / 2;
      const h = state.tileHeight * state.camera.zoom / 2;

      ctx.beginPath();
      ctx.moveTo(screen.x, screen.y - h);
      ctx.lineTo(screen.x + w, screen.y);
      ctx.lineTo(screen.x, screen.y + h);
      ctx.lineTo(screen.x - w, screen.y);
      ctx.closePath();

      ctx.fillStyle = state.mode === 'game' ? 'rgba(233, 69, 96, 0.3)' : 'rgba(100, 200, 255, 0.3)';
      ctx.fill();
      ctx.strokeStyle = state.mode === 'game' ? '#e94560' : '#64c8ff';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    let animationFrame = 0;
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw in isometric order (back to front)
      for (let y = 0; y < state.gridHeight; y++) {
        for (let x = 0; x < state.gridWidth; x++) {
          const tile = state.map[y]?.[x];
          if (!tile) continue;

          const elevation = tile.floor?.elevation || 0;

          // Draw floor
          if (tile.floor !== null) {
            const floorType = tileTypes.floors[tile.floor.type];
            let colors = floorType.colors;

            // Animate water
            if (floorType.animated && state.animateWater) {
              const shift = Math.sin((animationFrame + x + y) * 0.1) * 20;
              colors = colors.map(c => {
                if (c.startsWith('rgba')) return c;
                const r = parseInt(c.slice(1, 3), 16);
                const g = parseInt(c.slice(3, 5), 16);
                const b = parseInt(c.slice(5, 7), 16);
                return `rgb(${r + shift}, ${g + shift}, ${b})`;
              });
            }

            drawIsometricTile(x, y, colors, elevation);
          }

          // Draw elevation sides
          if (elevation > 0) {
            const screen = worldToScreen(x, y, 0);
            const w = state.tileWidth * state.camera.zoom / 2;
            const h = state.tileHeight * state.camera.zoom / 2;
            const elevH = elevation * state.tileHeight * state.camera.zoom;

            // Left side
            ctx.fillStyle = '#3a5f95';
            ctx.beginPath();
            ctx.moveTo(screen.x - w, screen.y);
            ctx.lineTo(screen.x, screen.y + h);
            ctx.lineTo(screen.x, screen.y + h - elevH);
            ctx.lineTo(screen.x - w, screen.y - elevH);
            ctx.closePath();
            ctx.fill();

            // Right side
            ctx.fillStyle = '#4a6fa5';
            ctx.beginPath();
            ctx.moveTo(screen.x, screen.y + h);
            ctx.lineTo(screen.x + w, screen.y);
            ctx.lineTo(screen.x + w, screen.y - elevH);
            ctx.lineTo(screen.x, screen.y + h - elevH);
            ctx.closePath();
            ctx.fill();
          }

          // Draw wall
          if (tile.wall !== null) {
            drawWall(x, y, tile.wall, elevation);
          }

          // Draw furniture
          if (tile.furniture !== null) {
            drawFurniture(x, y, tile.furniture, elevation);
          }
        }

        // Draw characters in this row
        for (const [id, char] of state.characters) {
          if (Math.floor(char.y) === y) {
            drawCharacter(char);
          }
        }
      }

      // Draw remaining characters
      for (const [id, char] of state.characters) {
        if (Math.floor(char.y) >= state.gridHeight) {
          drawCharacter(char);
        }
      }

      // Draw path
      drawPath();

      // Draw hover highlight
      drawHoverHighlight();

      // Grid overlay
      if (state.showGrid && state.mode === 'edit') {
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        for (let y = 0; y <= state.gridHeight; y++) {
          for (let x = 0; x <= state.gridWidth; x++) {
            const screen = worldToScreen(x, y);
            if (x < state.gridWidth) {
              const next = worldToScreen(x + 1, y);
              ctx.beginPath();
              ctx.moveTo(screen.x, screen.y);
              ctx.lineTo(next.x, next.y);
              ctx.stroke();
            }
            if (y < state.gridHeight) {
              const next = worldToScreen(x, y + 1);
              ctx.beginPath();
              ctx.moveTo(screen.x, screen.y);
              ctx.lineTo(next.x, next.y);
              ctx.stroke();
            }
          }
        }
      }

      animationFrame++;
    }

    // Animation loop
    function animate() {
      render();
      requestAnimationFrame(animate);
    }

    // ===== PATHFINDING (A*) =====
    function findPath(startX, startY, endX, endY) {
      const openSet = [];
      const closedSet = new Set();
      const cameFrom = new Map();
      const gScore = new Map();
      const fScore = new Map();

      const key = (x, y) => `${x},${y}`;
      const heuristic = (x1, y1, x2, y2) => Math.abs(x1 - x2) + Math.abs(y1 - y2);

      openSet.push({ x: startX, y: startY });
      gScore.set(key(startX, startY), 0);
      fScore.set(key(startX, startY), heuristic(startX, startY, endX, endY));

      while (openSet.length > 0) {
        // Get node with lowest fScore
        openSet.sort((a, b) => (fScore.get(key(a.x, a.y)) || Infinity) - (fScore.get(key(b.x, b.y)) || Infinity));
        const current = openSet.shift();

        if (current.x === endX && current.y === endY) {
          // Reconstruct path
          const path = [{ x: endX, y: endY }];
          let curr = key(endX, endY);
          while (cameFrom.has(curr)) {
            curr = cameFrom.get(curr);
            const [x, y] = curr.split(',').map(Number);
            path.unshift({ x, y });
          }
          return path;
        }

        closedSet.add(key(current.x, current.y));

        // Check neighbors (8 directions for isometric)
        const neighbors = [
          { x: current.x - 1, y: current.y },
          { x: current.x + 1, y: current.y },
          { x: current.x, y: current.y - 1 },
          { x: current.x, y: current.y + 1 },
          { x: current.x - 1, y: current.y - 1 },
          { x: current.x + 1, y: current.y - 1 },
          { x: current.x - 1, y: current.y + 1 },
          { x: current.x + 1, y: current.y + 1 }
        ];

        for (const neighbor of neighbors) {
          if (neighbor.x < 0 || neighbor.x >= state.gridWidth ||
              neighbor.y < 0 || neighbor.y >= state.gridHeight) continue;

          const tile = state.map[neighbor.y][neighbor.x];
          if (!tile.walkable || tile.wall !== null) continue;

          if (closedSet.has(key(neighbor.x, neighbor.y))) continue;

          const tentativeG = (gScore.get(key(current.x, current.y)) || 0) +
                            (neighbor.x !== current.x && neighbor.y !== current.y ? 1.414 : 1);

          const neighborKey = key(neighbor.x, neighbor.y);
          if (!openSet.find(n => n.x === neighbor.x && n.y === neighbor.y)) {
            openSet.push(neighbor);
          } else if (tentativeG >= (gScore.get(neighborKey) || Infinity)) {
            continue;
          }

          cameFrom.set(neighborKey, key(current.x, current.y));
          gScore.set(neighborKey, tentativeG);
          fScore.set(neighborKey, tentativeG + heuristic(neighbor.x, neighbor.y, endX, endY));
        }
      }

      return []; // No path found
    }

    // ===== CHARACTER MOVEMENT =====
    function moveCharacterAlongPath(characterId) {
      const character = state.characters.get(characterId);
      if (!character || state.currentPath.length === 0) {
        state.walkingCharacter = null;
        state.currentPath = [];
        return;
      }

      const target = state.currentPath[0];
      const dx = target.x - character.x;
      const dy = target.y - character.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      const speed = character.speed || 0.05;

      if (dist < speed) {
        character.x = target.x;
        character.y = target.y;
        state.currentPath.shift();

        emit('characterMoved', {
          id: characterId,
          from: { x: character.x - dx, y: character.y - dy },
          to: { x: character.x, y: character.y }
        });

        if (state.currentPath.length === 0) {
          state.walkingCharacter = null;
          character.walking = false;
        } else {
          setTimeout(() => moveCharacterAlongPath(characterId), 50);
        }
      } else {
        character.x += (dx / dist) * speed;
        character.y += (dy / dist) * speed;

        // Update direction
        if (Math.abs(dx) > Math.abs(dy)) {
          character.direction = dx > 0 ? 'e' : 'w';
        } else {
          character.direction = dy > 0 ? 's' : 'n';
        }

        setTimeout(() => moveCharacterAlongPath(characterId), 16);
      }
    }

    // ===== EVENT HANDLERS =====
    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 1 || (e.button === 0 && e.ctrlKey)) {
        state.isDragging = true;
        state.dragStart = { x: e.clientX - state.camera.x, y: e.clientY - state.camera.y };
        canvas.style.cursor = 'grabbing';
      }
    });

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;

      if (state.isDragging) {
        state.camera.x = e.clientX - state.dragStart.x;
        state.camera.y = e.clientY - state.dragStart.y;
        return;
      }

      state.hoveredTile = screenToWorld(mouseX, mouseY);
      updateStatus();
    });

    canvas.addEventListener('mouseup', () => {
      state.isDragging = false;
      canvas.style.cursor = 'default';
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
      state.camera.zoom = Math.max(0.5, Math.min(2, state.camera.zoom * zoomFactor));
    });

    canvas.addEventListener('click', (e) => {
      if (state.isDragging) return;

      const rect = canvas.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      const tilePos = screenToWorld(mouseX, mouseY);

      if (tilePos.x < 0 || tilePos.x >= state.gridWidth ||
          tilePos.y < 0 || tilePos.y >= state.gridHeight) return;

      const tile = state.map[tilePos.y][tilePos.x];

      if (state.mode === 'game') {
        handleGameClick(tilePos, tile);
      } else {
        handleEditClick(tilePos, tile);
      }

      emit('tileClicked', { x: tilePos.x, y: tilePos.y, tile, mode: state.mode });
    });

    function handleGameClick(pos, tile) {
      // Check if clicked on a character
      for (const [id, char] of state.characters) {
        if (Math.floor(char.x) === pos.x && Math.floor(char.y) === pos.y) {
          state.selectedCharacter = id;
          emit('characterClicked', { id, character: char });
          return;
        }
      }

      // If a character is selected, try to move it
      if (state.selectedCharacter && tile.walkable && tile.wall === null) {
        const character = state.characters.get(state.selectedCharacter);
        if (character) {
          const path = findPath(
            Math.floor(character.x), Math.floor(character.y),
            pos.x, pos.y
          );

          if (path.length > 0) {
            state.currentPath = path;
            state.walkingCharacter = state.selectedCharacter;
            character.walking = true;

            emit('pathRequest', {
              characterId: state.selectedCharacter,
              from: { x: Math.floor(character.x), y: Math.floor(character.y) },
              to: pos
            });

            moveCharacterAlongPath(state.selectedCharacter);
          }
        }
      }
    }

    function handleEditClick(pos, tile) {
      switch (state.tool) {
        case 'floor':
          tile.floor = { type: state.selectedTile.variant, elevation: tile.floor?.elevation || 0 };
          tile.walkable = true;
          break;
        case 'wall':
          tile.wall = state.selectedTile.variant;
          tile.walkable = false;
          break;
        case 'furniture':
          tile.furniture = state.selectedTile.variant;
          break;
        case 'erase':
          tile.floor = { type: 0, elevation: 0 };
          tile.wall = null;
          tile.furniture = null;
          tile.walkable = true;
          break;
        case 'elevation':
          if (tile.floor) {
            tile.floor.elevation = (tile.floor.elevation + 1) % 4;
          }
          break;
      }

      emit('mapChanged', { map: state.map });
    }

    // ===== TOOLBAR HANDLERS =====
    document.getElementById('btnEdit').onclick = () => setMode('edit');
    document.getElementById('btnGame').onclick = () => setMode('game');

    function setMode(mode) {
      state.mode = mode;
      document.getElementById('btnEdit').classList.toggle('active', mode === 'edit');
      document.getElementById('btnGame').classList.toggle('active', mode === 'game');
      document.getElementById('tilePalette').classList.toggle('visible', mode === 'edit' && state.tool !== 'select');
      updateStatus();
      emit('modeChanged', mode);
    }

    const tools = ['select', 'floor', 'wall', 'furniture', 'erase', 'elevation'];
    tools.forEach(tool => {
      document.getElementById(`tool${tool.charAt(0).toUpperCase() + tool.slice(1)}`).onclick = () => setTool(tool);
    });

    function setTool(tool) {
      state.tool = tool;
      tools.forEach(t => {
        document.getElementById(`tool${t.charAt(0).toUpperCase() + t.slice(1)}`).classList.toggle('active', t === tool);
      });

      // Show palette for relevant tools
      const showPalette = ['floor', 'wall', 'furniture'].includes(tool);
      document.getElementById('tilePalette').classList.toggle('visible', showPalette && state.mode === 'edit');

      if (tool === 'floor') state.selectedTile.type = 'floor';
      else if (tool === 'wall') state.selectedTile.type = 'wall';
      else if (tool === 'furniture') state.selectedTile.type = 'furniture';

      updateStatus();
    }

    document.getElementById('btnApplyGrid').onclick = () => {
      state.gridWidth = parseInt(document.getElementById('gridWidth').value) || 10;
      state.gridHeight = parseInt(document.getElementById('gridHeight').value) || 10;
      initMap();
      emit('mapChanged', { map: state.map, gridWidth: state.gridWidth, gridHeight: state.gridHeight });
    };

    document.getElementById('btnPalette').onclick = () => {
      document.getElementById('tilePalette').classList.toggle('visible');
    };

    document.getElementById('btnSettings').onclick = () => {
      document.getElementById('settingsPanel').classList.toggle('visible');
    };

    document.getElementById('btnApplySettings').onclick = () => {
      state.tileWidth = parseInt(document.getElementById('tileWidth').value) || 64;
      state.tileHeight = parseInt(document.getElementById('tileHeight').value) || 32;
      state.wallHeight = parseInt(document.getElementById('wallHeight').value) || 48;
      state.showGrid = document.getElementById('showGrid').checked;
      state.animateWater = document.getElementById('animateWater').checked;
      document.getElementById('settingsPanel').classList.remove('visible');
    };

    document.getElementById('btnClear').onclick = () => {
      if (confirm('Clear entire map?')) {
        initMap();
        state.characters.clear();
        emit('mapChanged', { map: state.map });
      }
    };

    document.getElementById('btnExport').onclick = () => {
      const data = {
        gridWidth: state.gridWidth,
        gridHeight: state.gridHeight,
        map: state.map,
        characters: Array.from(state.characters.entries())
      };
      emit('mapExport', data);

      // Also download as JSON
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'isometric-map.json';
      a.click();
      URL.revokeObjectURL(url);
    };

    // ===== CHARACTER MANAGEMENT =====
    document.getElementById('btnAddChar').onclick = () => {
      // Add a test character at a random walkable position
      let x = Math.floor(state.gridWidth / 2);
      let y = Math.floor(state.gridHeight / 2);

      // Find walkable tile
      for (let tries = 0; tries < 50; tries++) {
        const tx = Math.floor(Math.random() * state.gridWidth);
        const ty = Math.floor(Math.random() * state.gridHeight);
        if (state.map[ty][tx].walkable && !state.map[ty][tx].wall) {
          x = tx;
          y = ty;
          break;
        }
      }

      const charId = 'char_' + Date.now();
      state.characters.set(charId, {
        id: charId,
        x: x,
        y: y,
        name: 'Test Character',
        color: '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0'),
        skinColor: '#ffcc99',
        direction: 's',
        speed: 0.05,
        walking: false
      });
      state.selectedCharacter = charId;
      updateStatus();
      setMode('game'); // Switch to game mode to move character
    };

    document.getElementById('btnLoadChar').onclick = () => {
      // Try to load from localStorage (set by Character Widget)
      const deployData = localStorage.getItem('gameCharacter_deploy');
      const savedData = localStorage.getItem('gameCharacter_saved');
      const charData = deployData || savedData;

      if (charData) {
        try {
          const data = JSON.parse(charData);

          // Find a walkable spawn position
          let x = data.x || Math.floor(state.gridWidth / 2);
          let y = data.y || Math.floor(state.gridHeight / 2);

          // Make sure spawn is walkable
          if (!state.map[y]?.[x]?.walkable || state.map[y]?.[x]?.wall) {
            for (let tries = 0; tries < 50; tries++) {
              const tx = Math.floor(Math.random() * state.gridWidth);
              const ty = Math.floor(Math.random() * state.gridHeight);
              if (state.map[ty][tx].walkable && !state.map[ty][tx].wall) {
                x = tx;
                y = ty;
                break;
              }
            }
          }

          const charId = data.id || 'char_' + Date.now();
          state.characters.set(charId, {
            id: charId,
            x: x,
            y: y,
            name: data.name || 'Player',
            color: data.color || '#4a90d9',
            skinColor: data.skinColor || '#ffcc99',
            direction: data.direction || 's',
            speed: data.speed || 0.05,
            spriteData: data.spriteData,
            walking: false
          });
          state.selectedCharacter = charId;
          updateStatus();
          setMode('game');

          // Clear deploy data after loading
          localStorage.removeItem('gameCharacter_deploy');

          alert(`Character "${data.name}" loaded! Click on tiles in game mode to move.`);
        } catch (e) {
          alert('Error loading character data');
        }
      } else {
        // Try clipboard
        navigator.clipboard.readText().then(text => {
          try {
            const data = JSON.parse(text);
            if (data.name || data.id) {
              let x = Math.floor(state.gridWidth / 2);
              let y = Math.floor(state.gridHeight / 2);

              const charId = data.id || 'char_' + Date.now();
              state.characters.set(charId, {
                id: charId,
                x: x,
                y: y,
                name: data.name || 'Player',
                color: data.color || '#4a90d9',
                skinColor: data.skinColor || '#ffcc99',
                direction: data.direction || 's',
                speed: data.speed || 0.05,
                spriteData: data.spriteData,
                walking: false
              });
              state.selectedCharacter = charId;
              updateStatus();
              setMode('game');
              alert(`Character "${data.name}" loaded from clipboard!`);
            }
          } catch (e) {
            alert('No character data found. Use Character Widget to deploy, or copy character JSON to clipboard.');
          }
        }).catch(() => {
          alert('No character data found. Use Character Widget to deploy a character first.');
        });
      }
    };

    document.getElementById('btnClearChars').onclick = () => {
      if (state.characters.size === 0) {
        alert('No characters to remove');
        return;
      }
      if (confirm(`Remove all ${state.characters.size} character(s)?`)) {
        state.characters.clear();
        state.selectedCharacter = null;
        state.currentPath = [];
        updateStatus();
      }
    };

    // ===== PALETTE SETUP =====
    function setupPalette() {
      const floorPalette = document.getElementById('floorPalette');
      const wallPalette = document.getElementById('wallPalette');
      const furniturePalette = document.getElementById('furniturePalette');

      tileTypes.floors.forEach((floor, i) => {
        const div = document.createElement('div');
        div.className = 'palette-tile';
        div.style.background = floor.colors[0];
        div.title = floor.name;
        div.onclick = () => selectPaletteTile('floor', i);
        floorPalette.appendChild(div);
      });

      tileTypes.walls.forEach((wall, i) => {
        const div = document.createElement('div');
        div.className = 'palette-tile';
        div.style.background = wall.colors[0];
        div.title = wall.name;
        div.onclick = () => selectPaletteTile('wall', i);
        wallPalette.appendChild(div);
      });

      tileTypes.furniture.forEach((furn, i) => {
        const div = document.createElement('div');
        div.className = 'palette-tile';
        div.textContent = furn.icon;
        div.style.display = 'flex';
        div.style.alignItems = 'center';
        div.style.justifyContent = 'center';
        div.style.background = 'var(--bg-tertiary)';
        div.title = furn.name;
        div.onclick = () => selectPaletteTile('furniture', i);
        furniturePalette.appendChild(div);
      });
    }

    function selectPaletteTile(type, variant) {
      state.selectedTile = { type, variant };

      // Update visual selection
      document.querySelectorAll('.palette-tile').forEach(el => el.classList.remove('selected'));
      const palettes = { floor: 'floorPalette', wall: 'wallPalette', furniture: 'furniturePalette' };
      const palette = document.getElementById(palettes[type]);
      palette.children[variant]?.classList.add('selected');

      // Set appropriate tool
      if (type === 'floor') setTool('floor');
      else if (type === 'wall') setTool('wall');
      else if (type === 'furniture') setTool('furniture');
    }

    // ===== STATUS BAR =====
    function updateStatus() {
      const toolNames = {
        select: 'Select', floor: 'Floor', wall: 'Wall',
        furniture: 'Furniture', erase: 'Erase', elevation: 'Elevation'
      };

      document.getElementById('statusLeft').textContent =
        `Mode: ${state.mode.charAt(0).toUpperCase() + state.mode.slice(1)} | Tool: ${toolNames[state.tool]}`;

      if (state.hoveredTile && state.hoveredTile.x >= 0 && state.hoveredTile.x < state.gridWidth &&
          state.hoveredTile.y >= 0 && state.hoveredTile.y < state.gridHeight) {
        const tile = state.map[state.hoveredTile.y][state.hoveredTile.x];
        const floorName = tile.floor ? tileTypes.floors[tile.floor.type]?.name : 'None';
        document.getElementById('statusCenter').textContent =
          `Tile: (${state.hoveredTile.x}, ${state.hoveredTile.y}) | Floor: ${floorName} | Elev: ${tile.floor?.elevation || 0}`;
      } else {
        document.getElementById('statusCenter').textContent = 'Tile: -';
      }

      document.getElementById('statusRight').textContent = `Characters: ${state.characters.size}`;
    }

    // ===== MESSAGE HANDLING =====
    function emit(type, payload) {
      window.parent.postMessage({
        type: 'widget:emit',
        payload: { type, payload }
      }, '*');
    }

    window.addEventListener('message', (event) => {
      const { type, portName, value } = event.data;

      if (type === 'pipeline:input') {
        switch (portName) {
          case 'setMap':
            if (value.map) state.map = value.map;
            if (value.gridWidth) state.gridWidth = value.gridWidth;
            if (value.gridHeight) state.gridHeight = value.gridHeight;
            break;

          case 'addCharacter':
            state.characters.set(value.id, {
              id: value.id,
              x: value.x || 0,
              y: value.y || 0,
              name: value.name || 'Character',
              color: value.color || '#4a90d9',
              skinColor: value.skinColor || '#ffcc99',
              direction: value.direction || 's',
              speed: value.speed || 0.05,
              spriteData: value.spriteData,
              elevation: value.elevation || 0,
              walking: false
            });
            updateStatus();
            break;

          case 'removeCharacter':
            state.characters.delete(value);
            if (state.selectedCharacter === value) {
              state.selectedCharacter = null;
            }
            updateStatus();
            break;

          case 'moveCharacter':
            const char = state.characters.get(value.id);
            if (char) {
              const path = findPath(Math.floor(char.x), Math.floor(char.y), value.x, value.y);
              if (path.length > 0) {
                state.currentPath = path;
                state.walkingCharacter = value.id;
                char.walking = true;
                moveCharacterAlongPath(value.id);
              }
            }
            break;

          case 'setTile':
            if (value.x >= 0 && value.x < state.gridWidth &&
                value.y >= 0 && value.y < state.gridHeight) {
              const tile = state.map[value.y][value.x];
              if (value.floor !== undefined) tile.floor = value.floor;
              if (value.wall !== undefined) tile.wall = value.wall;
              if (value.furniture !== undefined) tile.furniture = value.furniture;
              if (value.walkable !== undefined) tile.walkable = value.walkable;
              emit('mapChanged', { map: state.map });
            }
            break;

          case 'setMode':
            setMode(value);
            break;

          case 'loadTileset':
            if (value.floors) tileTypes.floors = value.floors;
            if (value.walls) tileTypes.walls = value.walls;
            if (value.furniture) tileTypes.furniture = value.furniture;
            setupPalette();
            break;
        }
      }
    });

    // ===== INITIALIZATION =====
    function init() {
      initMap();
      setupPalette();
      resizeCanvas();
      animate();
      window.parent.postMessage({ type: 'READY' }, '*');
    }

    window.addEventListener('resize', resizeCanvas);
    init();
  </script>
</body>
</html>
