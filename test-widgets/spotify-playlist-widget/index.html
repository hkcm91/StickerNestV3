<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Spotify Playlist Widget</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background: linear-gradient(145deg, #121212 0%, #191414 50%, #1a1a1a 100%);
      color: #fff;
      overflow: hidden;
    }

    /* Header */
    .header {
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .header h1 {
      font-size: 15px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1;
    }

    .header h1 .icon {
      width: 24px;
      height: 24px;
      background: #1DB954;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .header-actions {
      display: flex;
      gap: 6px;
    }

    /* Playlist selector */
    .playlist-selector {
      padding: 10px 16px;
      background: rgba(0, 0, 0, 0.2);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      gap: 8px;
      align-items: center;
      flex-shrink: 0;
    }

    .playlist-selector select {
      flex: 1;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
    }

    .playlist-selector select:focus {
      outline: none;
      border-color: #1DB954;
    }

    .playlist-selector select option {
      background: #282828;
      color: #fff;
    }

    /* Add track area */
    .add-track {
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.2);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      gap: 8px;
      flex-shrink: 0;
    }

    .add-track input {
      flex: 1;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      padding: 10px 14px;
      border-radius: 20px;
      font-size: 13px;
    }

    .add-track input:focus {
      outline: none;
      border-color: #1DB954;
    }

    .add-track input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    /* Buttons */
    .btn {
      padding: 8px 14px;
      border: none;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 5px;
      white-space: nowrap;
    }

    .btn-primary {
      background: #1DB954;
      color: #000;
    }

    .btn-primary:hover {
      background: #1ed760;
      transform: scale(1.02);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .btn-secondary.active {
      background: rgba(29, 185, 84, 0.3);
      color: #1DB954;
    }

    .btn-icon {
      width: 32px;
      height: 32px;
      padding: 0;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-small {
      padding: 5px 10px;
      font-size: 11px;
    }

    /* Player controls */
    .player-controls {
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.3);
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      display: flex;
      align-items: center;
      gap: 12px;
      flex-shrink: 0;
    }

    .now-playing {
      flex: 1;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .now-playing span {
      color: #1DB954;
      font-weight: 500;
    }

    .control-buttons {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .control-buttons .btn-icon {
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      font-size: 14px;
    }

    .control-buttons .btn-icon:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .control-buttons .btn-icon.play-btn {
      width: 40px;
      height: 40px;
      background: #1DB954;
      color: #000;
    }

    .control-buttons .btn-icon.play-btn:hover {
      background: #1ed760;
      transform: scale(1.05);
    }

    /* Track list */
    .track-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .track-list::-webkit-scrollbar {
      width: 6px;
    }

    .track-list::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.05);
    }

    .track-list::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.2);
      border-radius: 3px;
    }

    .track-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .track-item:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .track-item.active {
      background: rgba(29, 185, 84, 0.2);
    }

    .track-item .track-number {
      width: 24px;
      font-size: 13px;
      color: rgba(255, 255, 255, 0.5);
      text-align: center;
    }

    .track-item.active .track-number {
      color: #1DB954;
    }

    .track-item .track-art {
      width: 44px;
      height: 44px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.1);
      object-fit: cover;
      flex-shrink: 0;
    }

    .track-item .track-info {
      flex: 1;
      min-width: 0;
    }

    .track-item .track-title {
      font-size: 13px;
      font-weight: 500;
      color: #fff;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .track-item.active .track-title {
      color: #1DB954;
    }

    .track-item .track-artist {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.5);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-top: 2px;
    }

    .track-item .track-duration {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
    }

    .track-item .track-actions {
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    .track-item:hover .track-actions {
      opacity: 1;
    }

    .track-item .track-actions button {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      color: #fff;
      border: none;
      cursor: pointer;
      font-size: 12px;
      transition: all 0.2s;
    }

    .track-item .track-actions button:hover {
      background: rgba(255, 70, 70, 0.6);
    }

    /* Empty state */
    .empty-state {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: rgba(255, 255, 255, 0.5);
      text-align: center;
      padding: 40px;
    }

    .empty-state .icon {
      font-size: 56px;
      margin-bottom: 16px;
      opacity: 0.4;
    }

    .empty-state h3 {
      font-size: 16px;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 8px;
    }

    .empty-state p {
      font-size: 13px;
      line-height: 1.5;
      max-width: 280px;
    }

    /* Spotify embed player (hidden by default) */
    .spotify-embed {
      display: none;
      width: 100%;
      height: 80px;
      flex-shrink: 0;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .spotify-embed.active {
      display: block;
    }

    .spotify-embed iframe {
      width: 100%;
      height: 100%;
      border: none;
    }

    /* Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: #282828;
      border-radius: 12px;
      padding: 24px;
      width: 90%;
      max-width: 320px;
    }

    .modal-content h3 {
      font-size: 16px;
      margin-bottom: 16px;
    }

    .modal-content input {
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #fff;
      padding: 12px 14px;
      border-radius: 8px;
      font-size: 14px;
      margin-bottom: 16px;
    }

    .modal-content input:focus {
      outline: none;
      border-color: #1DB954;
    }

    .modal-actions {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    /* Toast */
    .toast {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: #282828;
      color: #fff;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 200;
      transition: transform 0.3s ease;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(29, 185, 84, 0.3);
    }

    .toast.show {
      transform: translateX(-50%) translateY(0);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>
      <span class="icon">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/>
        </svg>
      </span>
      Spotify
    </h1>
    <div class="header-actions">
      <button class="btn btn-secondary btn-icon" id="shuffleBtn" title="Shuffle">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
          <path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>
        </svg>
      </button>
    </div>
  </div>

  <div class="playlist-selector">
    <select id="playlistSelect"></select>
    <button class="btn btn-secondary btn-small" id="addPlaylistBtn">+ New</button>
    <button class="btn btn-secondary btn-small" id="deletePlaylistBtn">Delete</button>
  </div>

  <div class="add-track">
    <input type="text" id="trackInput" placeholder="Paste Spotify track, album, or playlist URL...">
    <button class="btn btn-primary" id="addTrackBtn">Add</button>
  </div>

  <div class="player-controls">
    <div class="now-playing" id="nowPlaying">No track selected</div>
    <div class="control-buttons">
      <button class="btn btn-icon" id="prevBtn" title="Previous">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
          <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
        </svg>
      </button>
      <button class="btn btn-icon play-btn" id="playBtn" title="Play">
        <svg id="playIcon" width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
          <path d="M8 5v14l11-7z"/>
        </svg>
      </button>
      <button class="btn btn-icon" id="nextBtn" title="Next">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
          <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/>
        </svg>
      </button>
    </div>
  </div>

  <div class="track-list" id="trackList">
    <div class="empty-state" id="emptyState">
      <div class="icon">
        <svg width="56" height="56" viewBox="0 0 24 24" fill="currentColor" opacity="0.4">
          <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/>
        </svg>
      </div>
      <h3>No Tracks Yet</h3>
      <p>Paste a Spotify URL above to add tracks, albums, or playlists to your collection</p>
    </div>
  </div>

  <div class="spotify-embed" id="spotifyEmbed">
    <iframe id="spotifyPlayer" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>
  </div>

  <div class="modal" id="newPlaylistModal">
    <div class="modal-content">
      <h3>New Playlist</h3>
      <input type="text" id="newPlaylistName" placeholder="Playlist name...">
      <div class="modal-actions">
        <button class="btn btn-secondary" id="cancelNewPlaylist">Cancel</button>
        <button class="btn btn-primary" id="confirmNewPlaylist">Create</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // ===== Widget Communication =====
    function emit(portId, payload) {
      // Emit via legacy widget:emit protocol
      window.parent.postMessage({
        type: 'widget:emit',
        payload: { type: portId, payload }
      }, '*');
      // Also emit via EVENT protocol for canvas-wide event broadcasting
      window.parent.postMessage({
        type: 'EVENT',
        payload: { type: portId, scope: 'canvas', payload: payload }
      }, '*');
    }

    function emitEvent(eventType, payload) {
      window.parent.postMessage({
        type: 'EVENT',
        payload: { type: eventType, scope: 'canvas', payload: payload }
      }, '*');
    }

    // ===== State =====
    let playlists = [];
    let currentPlaylistId = null;
    let currentTrackIndex = -1;
    let isPlaying = false;
    let isShuffled = false;
    let shuffledOrder = [];

    // ===== Spotify URL Parsing =====
    function parseSpotifyUrl(url) {
      // Handle various Spotify URL formats
      // https://open.spotify.com/track/4iV5W9uYEdYUVa79Axb7Rh
      // https://open.spotify.com/album/4iV5W9uYEdYUVa79Axb7Rh
      // https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M
      // spotify:track:4iV5W9uYEdYUVa79Axb7Rh

      const urlMatch = url.match(/spotify\.com\/(track|album|playlist|artist)\/([a-zA-Z0-9]+)/);
      if (urlMatch) {
        return { type: urlMatch[1], id: urlMatch[2] };
      }

      const uriMatch = url.match(/spotify:(track|album|playlist|artist):([a-zA-Z0-9]+)/);
      if (uriMatch) {
        return { type: uriMatch[1], id: uriMatch[2] };
      }

      return null;
    }

    function getSpotifyEmbedUrl(type, id) {
      return `https://open.spotify.com/embed/${type}/${id}?utm_source=generator&theme=0`;
    }

    function getSpotifyArtworkUrl(type, id) {
      // Placeholder artwork - in real implementation would fetch from Spotify API
      return `https://i.scdn.co/image/ab67616d0000b273${id.substring(0, 22)}`;
    }

    // ===== Playlist Management =====
    function getCurrentPlaylist() {
      return playlists.find(p => p.id === currentPlaylistId);
    }

    function createPlaylist(name) {
      const playlist = {
        id: 'pl_' + Date.now(),
        name: name || 'New Playlist',
        tracks: []
      };
      playlists.push(playlist);
      currentPlaylistId = playlist.id;
      savePlaylists();
      renderPlaylistSelector();
      renderTrackList();
      showToast(`Created: ${playlist.name}`);
    }

    function deletePlaylist(id) {
      const idx = playlists.findIndex(p => p.id === id);
      if (idx === -1) return;
      const name = playlists[idx].name;
      playlists.splice(idx, 1);
      if (playlists.length === 0) {
        createPlaylist('My Playlist');
      } else if (currentPlaylistId === id) {
        currentPlaylistId = playlists[0].id;
      }
      savePlaylists();
      renderPlaylistSelector();
      renderTrackList();
      showToast(`Deleted: ${name}`);
    }

    function selectPlaylist(id) {
      currentPlaylistId = id;
      currentTrackIndex = -1;
      generateShuffledOrder();
      savePlaylists();
      renderTrackList();
    }

    // ===== Track Management =====
    function addTrack(spotifyUrl) {
      const parsed = parseSpotifyUrl(spotifyUrl);
      if (!parsed) {
        showToast('Invalid Spotify URL');
        return;
      }

      const playlist = getCurrentPlaylist();
      if (!playlist) return;

      // Check for duplicates
      if (playlist.tracks.some(t => t.spotifyId === parsed.id && t.type === parsed.type)) {
        showToast('Already in playlist');
        return;
      }

      const track = {
        id: 'tr_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6),
        type: parsed.type,
        spotifyId: parsed.id,
        title: `${parsed.type.charAt(0).toUpperCase() + parsed.type.slice(1)} ${parsed.id.substring(0, 8)}...`,
        artist: 'Loading...',
        duration: '--:--',
        artwork: null,
        embedUrl: getSpotifyEmbedUrl(parsed.type, parsed.id)
      };

      playlist.tracks.push(track);
      generateShuffledOrder();
      savePlaylists();
      renderTrackList();
      showToast(`Added ${parsed.type}`);

      // Fetch track info via oEmbed
      fetchTrackInfo(track);
    }

    async function fetchTrackInfo(track) {
      try {
        const oembedUrl = `https://open.spotify.com/oembed?url=https://open.spotify.com/${track.type}/${track.spotifyId}`;
        const response = await fetch(oembedUrl);
        if (response.ok) {
          const data = await response.json();
          track.title = data.title || track.title;
          track.artist = data.provider_name || 'Spotify';
          track.artwork = data.thumbnail_url || null;
          savePlaylists();
          renderTrackList();
        }
      } catch (e) {
        console.log('Could not fetch track info:', e);
      }
    }

    function removeTrack(id) {
      const playlist = getCurrentPlaylist();
      if (!playlist) return;
      const idx = playlist.tracks.findIndex(t => t.id === id);
      if (idx === -1) return;
      const title = playlist.tracks[idx].title;
      playlist.tracks.splice(idx, 1);
      if (currentTrackIndex >= playlist.tracks.length) {
        currentTrackIndex = playlist.tracks.length - 1;
      }
      generateShuffledOrder();
      savePlaylists();
      renderTrackList();
      showToast(`Removed: ${title}`);
    }

    // ===== Playback =====
    function playTrack(index) {
      const playlist = getCurrentPlaylist();
      if (!playlist || index < 0 || index >= playlist.tracks.length) return;

      currentTrackIndex = index;
      const actualIndex = isShuffled ? shuffledOrder[index] : index;
      const track = playlist.tracks[actualIndex];

      // Update embed player
      const embed = document.getElementById('spotifyEmbed');
      const player = document.getElementById('spotifyPlayer');
      player.src = track.embedUrl;
      embed.classList.add('active');

      isPlaying = true;
      updatePlayButton();
      renderTrackList();
      updateNowPlaying(track);
      emitTrackChanged(track, index);
      emitPreview(track);
    }

    function togglePlay() {
      if (currentTrackIndex === -1) {
        // Start from beginning if nothing selected
        const playlist = getCurrentPlaylist();
        if (playlist && playlist.tracks.length > 0) {
          playTrack(0);
        }
        return;
      }

      isPlaying = !isPlaying;
      updatePlayButton();
      emitPlayState();
    }

    function nextTrack() {
      const playlist = getCurrentPlaylist();
      if (!playlist || playlist.tracks.length === 0) return;

      let nextIndex = currentTrackIndex + 1;
      if (nextIndex >= playlist.tracks.length) {
        nextIndex = 0;
      }
      playTrack(nextIndex);
    }

    function prevTrack() {
      const playlist = getCurrentPlaylist();
      if (!playlist || playlist.tracks.length === 0) return;

      let prevIndex = currentTrackIndex - 1;
      if (prevIndex < 0) {
        prevIndex = playlist.tracks.length - 1;
      }
      playTrack(prevIndex);
    }

    function toggleShuffle() {
      isShuffled = !isShuffled;
      document.getElementById('shuffleBtn').classList.toggle('active', isShuffled);
      generateShuffledOrder();
      savePlaylists();
    }

    function generateShuffledOrder() {
      const playlist = getCurrentPlaylist();
      if (!playlist) return;

      shuffledOrder = Array.from({ length: playlist.tracks.length }, (_, i) => i);

      if (isShuffled) {
        // Fisher-Yates shuffle
        for (let i = shuffledOrder.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffledOrder[i], shuffledOrder[j]] = [shuffledOrder[j], shuffledOrder[i]];
        }
      }
    }

    // ===== Event Emission =====
    function emitTrackChanged(track, index) {
      emit('trackChanged', {
        spotifyId: track.spotifyId,
        type: track.type,
        title: track.title,
        artist: track.artist,
        artwork: track.artwork,
        embedUrl: track.embedUrl,
        index: index
      });
      emitEvent('spotify:changed', {
        spotifyId: track.spotifyId,
        type: track.type,
        title: track.title,
        artist: track.artist,
        artwork: track.artwork
      });
    }

    function emitPlayState() {
      const playlist = getCurrentPlaylist();
      const track = playlist?.tracks[isShuffled ? shuffledOrder[currentTrackIndex] : currentTrackIndex];
      emit('playStateChanged', {
        playing: isPlaying,
        spotifyId: track?.spotifyId || null
      });
    }

    function emitPreview(track) {
      if (!track) return;
      emit('preview', {
        type: 'spotify',
        spotifyId: track.spotifyId,
        spotifyType: track.type,
        title: track.title,
        artist: track.artist,
        thumbnail: track.artwork,
        embedUrl: track.embedUrl,
        timestamp: Date.now(),
        playing: isPlaying
      });
      emitEvent('spotify:preview', {
        type: 'spotify',
        spotifyId: track.spotifyId,
        spotifyType: track.type,
        title: track.title,
        artist: track.artist,
        thumbnail: track.artwork,
        embedUrl: track.embedUrl
      });
    }

    // ===== UI Rendering =====
    function renderPlaylistSelector() {
      const select = document.getElementById('playlistSelect');
      select.innerHTML = playlists.map(p =>
        `<option value="${p.id}">${escapeHtml(p.name)} (${p.tracks.length})</option>`
      ).join('');

      if (currentPlaylistId) {
        select.value = currentPlaylistId;
      }
    }

    function renderTrackList() {
      const container = document.getElementById('trackList');
      const emptyState = document.getElementById('emptyState');
      const playlist = getCurrentPlaylist();

      if (!playlist || playlist.tracks.length === 0) {
        emptyState.style.display = 'flex';
        container.innerHTML = '';
        container.appendChild(emptyState);
        return;
      }

      emptyState.style.display = 'none';

      const displayOrder = isShuffled
        ? shuffledOrder.map((actualIdx, displayIdx) => ({ track: playlist.tracks[actualIdx], displayIdx, actualIdx }))
        : playlist.tracks.map((track, idx) => ({ track, displayIdx: idx, actualIdx: idx }));

      container.innerHTML = displayOrder.map(({ track, displayIdx, actualIdx }) => `
        <div class="track-item ${displayIdx === currentTrackIndex ? 'active' : ''}" data-index="${displayIdx}">
          <span class="track-number">${displayIdx + 1}</span>
          ${track.artwork
            ? `<img class="track-art" src="${track.artwork}" alt="">`
            : `<div class="track-art" style="display: flex; align-items: center; justify-content: center; color: rgba(255,255,255,0.3);">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
                  <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                </svg>
              </div>`
          }
          <div class="track-info">
            <div class="track-title">${escapeHtml(track.title)}</div>
            <div class="track-artist">${escapeHtml(track.artist)}</div>
          </div>
          <span class="track-duration">${track.duration}</span>
          <div class="track-actions">
            <button data-remove="${track.id}" title="Remove">&times;</button>
          </div>
        </div>
      `).join('');

      // Event listeners
      container.querySelectorAll('.track-item').forEach(item => {
        item.addEventListener('click', (e) => {
          if (e.target.hasAttribute('data-remove')) {
            e.stopPropagation();
            removeTrack(e.target.getAttribute('data-remove'));
          } else {
            playTrack(parseInt(item.dataset.index));
          }
        });
      });
    }

    function updatePlayButton() {
      const icon = document.getElementById('playIcon');
      if (isPlaying) {
        icon.innerHTML = '<path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>';
      } else {
        icon.innerHTML = '<path d="M8 5v14l11-7z"/>';
      }
    }

    function updateNowPlaying(track) {
      document.getElementById('nowPlaying').innerHTML = track
        ? `Now playing: <span>${escapeHtml(track.title)}</span>`
        : 'No track selected';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function showToast(message) {
      const toast = document.getElementById('toast');
      toast.textContent = message;
      toast.classList.add('show');
      setTimeout(() => toast.classList.remove('show'), 2500);
    }

    // ===== Storage =====
    function savePlaylists() {
      try {
        localStorage.setItem('spotify-playlist-widget', JSON.stringify({
          playlists,
          currentPlaylistId,
          isShuffled
        }));
      } catch (e) {
        console.error('Failed to save playlists:', e);
      }
    }

    function loadPlaylists() {
      try {
        const data = JSON.parse(localStorage.getItem('spotify-playlist-widget'));
        if (data) {
          playlists = data.playlists || [];
          currentPlaylistId = data.currentPlaylistId;
          isShuffled = data.isShuffled || false;
        }
      } catch (e) {
        console.error('Failed to load playlists:', e);
      }

      if (playlists.length === 0) {
        createPlaylist('My Playlist');
      } else {
        if (!currentPlaylistId || !playlists.find(p => p.id === currentPlaylistId)) {
          currentPlaylistId = playlists[0].id;
        }
        generateShuffledOrder();
      }

      renderPlaylistSelector();
      renderTrackList();
      document.getElementById('shuffleBtn').classList.toggle('active', isShuffled);
    }

    // ===== Event Listeners =====
    document.getElementById('playlistSelect').addEventListener('change', (e) => {
      selectPlaylist(e.target.value);
    });

    document.getElementById('addPlaylistBtn').addEventListener('click', () => {
      document.getElementById('newPlaylistModal').classList.add('active');
      document.getElementById('newPlaylistName').focus();
    });

    document.getElementById('deletePlaylistBtn').addEventListener('click', () => {
      if (currentPlaylistId && confirm('Delete this playlist?')) {
        deletePlaylist(currentPlaylistId);
      }
    });

    document.getElementById('cancelNewPlaylist').addEventListener('click', () => {
      document.getElementById('newPlaylistModal').classList.remove('active');
      document.getElementById('newPlaylistName').value = '';
    });

    document.getElementById('confirmNewPlaylist').addEventListener('click', () => {
      const name = document.getElementById('newPlaylistName').value.trim();
      if (name) {
        createPlaylist(name);
        document.getElementById('newPlaylistModal').classList.remove('active');
        document.getElementById('newPlaylistName').value = '';
      }
    });

    document.getElementById('newPlaylistName').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('confirmNewPlaylist').click();
      }
      if (e.key === 'Escape') {
        document.getElementById('cancelNewPlaylist').click();
      }
    });

    document.getElementById('addTrackBtn').addEventListener('click', () => {
      const input = document.getElementById('trackInput');
      const url = input.value.trim();
      if (url) {
        addTrack(url);
        input.value = '';
      }
    });

    document.getElementById('trackInput').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('addTrackBtn').click();
      }
    });

    document.getElementById('playBtn').addEventListener('click', togglePlay);
    document.getElementById('prevBtn').addEventListener('click', prevTrack);
    document.getElementById('nextBtn').addEventListener('click', nextTrack);
    document.getElementById('shuffleBtn').addEventListener('click', toggleShuffle);

    // ===== Handle Incoming Messages =====
    window.addEventListener('message', (event) => {
      const data = event.data;

      if (data.type === 'pipeline:input') {
        const { portName, value } = data;
        switch (portName) {
          case 'addTrack':
            if (typeof value === 'string') addTrack(value);
            break;
          case 'play':
            if (!isPlaying) togglePlay();
            break;
          case 'pause':
            if (isPlaying) togglePlay();
            break;
          case 'next':
            nextTrack();
            break;
          case 'previous':
            prevTrack();
            break;
          case 'shuffle':
            if (typeof value === 'boolean' && value !== isShuffled) toggleShuffle();
            break;
        }
        return;
      }

      if (data.type === 'widget:event') {
        const portName = data.payload?.type;
        const value = data.payload?.payload;
        switch (portName) {
          case 'addTrack':
            if (typeof value === 'string') addTrack(value);
            break;
          case 'playlist:add':
            if (typeof value === 'string') addTrack(value);
            break;
          case 'playlist:control':
            if (value === 'play') togglePlay();
            else if (value === 'next') nextTrack();
            else if (value === 'prev' || value === 'previous') prevTrack();
            break;
        }
      }

      // Handle EVENT type messages
      if (data.type === 'EVENT' && data.payload) {
        const evt = data.payload;
        if (evt.type === 'playlist:add' && evt.payload) {
          addTrack(evt.payload);
        }
      }
    });

    // ===== Initialization =====
    loadPlaylists();

    // Signal ready
    window.parent.postMessage({ type: 'READY' }, '*');
  </script>
</body>
</html>
