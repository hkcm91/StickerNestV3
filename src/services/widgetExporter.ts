/**
 * StickerNest v2 - Widget Exporter
 * Generate downloadable widget files
 */

import type { DraftWidget } from '../ai/DraftManager';
import type { WidgetManifest } from '../types/manifest';

export type ExportFormat = 'html' | 'bundle' | 'zip';

export interface ExportOptions {
  format: ExportFormat;
  /** Include WidgetAPI mock for standalone execution */
  includeWidgetAPI?: boolean;
  /** Minify output */
  minify?: boolean;
  /** Include metadata comments */
  includeMetadata?: boolean;
}

export interface ExportResult {
  success: boolean;
  filename: string;
  content: string | Blob;
  mimeType: string;
  error?: string;
}

/**
 * Generate mock WidgetAPI script for standalone execution
 */
function generateWidgetAPIMock(): string {
  return `
<script>
// StickerNest WidgetAPI Mock - For standalone execution
window.WidgetAPI = {
  _state: {},
  _eventHandlers: {},
  _outputHandlers: {},
  
  emitEvent: function(event) {
    console.log('[WidgetAPI Mock] Event emitted:', event);
    const handlers = this._eventHandlers['*'] || [];
    handlers.forEach(h => h(event));
  },
  
  onEvent: function(type, handler) {
    if (!this._eventHandlers[type]) this._eventHandlers[type] = [];
    this._eventHandlers[type].push(handler);
    return function() {
      const idx = this._eventHandlers[type].indexOf(handler);
      if (idx > -1) this._eventHandlers[type].splice(idx, 1);
    }.bind(this);
  },
  
  emitOutput: function(name, value) {
    console.log('[WidgetAPI Mock] Output:', name, value);
  },
  
  onInput: function(name, handler) {
    console.log('[WidgetAPI Mock] Registered input handler:', name);
    return function() {};
  },
  
  getState: function() {
    return this._state;
  },
  
  setState: function(state) {
    this._state = { ...this._state, ...state };
    console.log('[WidgetAPI Mock] State updated:', this._state);
  },
  
  getAssetUrl: function(path) {
    return path;
  },
  
  log: function(...args) { console.log('[Widget]', ...args); },
  info: function(...args) { console.info('[Widget]', ...args); },
  warn: function(...args) { console.warn('[Widget]', ...args); },
  error: function(...args) { console.error('[Widget]', ...args); },
  debugLog: function(...args) { console.log('[Widget Debug]', ...args); },
};

console.log('[WidgetAPI Mock] Initialized - Running in standalone mode');
</script>
`;
}

/**
 * Generate metadata header
 */
function generateMetadataHeader(manifest: WidgetManifest): string {
  return `<!--
  StickerNest Widget
  Name: ${manifest.name}
  ID: ${manifest.id}
  Version: ${manifest.version}
  Kind: ${manifest.kind}
  Generated: ${new Date().toISOString()}
  
  This widget was generated by StickerNest Widget Pipeline AI.
  https://stickernest.com
-->
`;
}

/**
 * Simple HTML minification
 */
function minifyHtml(html: string): string {
  return html
    .replace(/\s+/g, ' ')
    .replace(/>\s+</g, '><')
    .replace(/<!--(?!<!)[^\[>].*?-->/g, '')
    .trim();
}

/**
 * Export as standalone HTML file
 */
function exportAsHtml(draft: DraftWidget, options: ExportOptions): ExportResult {
  let content = draft.html;
  
  // Add WidgetAPI mock if requested
  if (options.includeWidgetAPI) {
    const apiMock = generateWidgetAPIMock();
    if (content.includes('<head>')) {
      content = content.replace('<head>', '<head>' + apiMock);
    } else if (content.includes('<body>')) {
      content = content.replace('<body>', '<body>' + apiMock);
    } else {
      content = apiMock + content;
    }
  }
  
  // Add metadata if requested
  if (options.includeMetadata) {
    content = generateMetadataHeader(draft.manifest) + content;
  }
  
  // Minify if requested
  if (options.minify) {
    content = minifyHtml(content);
  }
  
  const filename = `${draft.manifest.id}.html`;
  
  return {
    success: true,
    filename,
    content,
    mimeType: 'text/html',
  };
}

/**
 * Export as widget bundle (manifest.json + index.html)
 */
function exportAsBundle(draft: DraftWidget, options: ExportOptions): ExportResult {
  const manifestJson = JSON.stringify(draft.manifest, null, 2);
  let htmlContent = draft.html;
  
  if (options.includeMetadata) {
    htmlContent = generateMetadataHeader(draft.manifest) + htmlContent;
  }
  
  if (options.minify) {
    htmlContent = minifyHtml(htmlContent);
  }
  
  // Create a bundle as JSON with both files
  const bundle = {
    manifest: draft.manifest,
    files: [
      {
        name: 'manifest.json',
        content: manifestJson,
      },
      {
        name: 'index.html',
        content: htmlContent,
      },
    ],
  };
  
  const filename = `${draft.manifest.id}-bundle.json`;
  
  return {
    success: true,
    filename,
    content: JSON.stringify(bundle, null, 2),
    mimeType: 'application/json',
  };
}

/**
 * Export as ZIP archive
 * Note: This creates a simple base64-encoded bundle since we can't use JSZip directly
 */
async function exportAsZip(draft: DraftWidget, options: ExportOptions): Promise<ExportResult> {
  // For now, we'll create a simple archive format
  // In production, you'd use JSZip or similar
  
  const manifestJson = JSON.stringify(draft.manifest, null, 2);
  let htmlContent = draft.html;
  
  if (options.includeWidgetAPI) {
    const apiMock = generateWidgetAPIMock();
    if (htmlContent.includes('<head>')) {
      htmlContent = htmlContent.replace('<head>', '<head>' + apiMock);
    } else {
      htmlContent = apiMock + htmlContent;
    }
  }
  
  if (options.includeMetadata) {
    htmlContent = generateMetadataHeader(draft.manifest) + htmlContent;
  }
  
  // Create a simple bundle format that can be extracted
  const archive = {
    type: 'stickernest-widget-archive',
    version: '1.0',
    widget: {
      id: draft.manifest.id,
      name: draft.manifest.name,
    },
    files: {
      'manifest.json': btoa(unescape(encodeURIComponent(manifestJson))),
      'index.html': btoa(unescape(encodeURIComponent(htmlContent))),
    },
  };
  
  const filename = `${draft.manifest.id}.snw`;
  
  return {
    success: true,
    filename,
    content: JSON.stringify(archive),
    mimeType: 'application/octet-stream',
  };
}

/**
 * Export a widget draft in the specified format
 */
export async function exportWidget(
  draft: DraftWidget,
  options: ExportOptions = { format: 'html' }
): Promise<ExportResult> {
  try {
    switch (options.format) {
      case 'html':
        return exportAsHtml(draft, options);
      case 'bundle':
        return exportAsBundle(draft, options);
      case 'zip':
        return await exportAsZip(draft, options);
      default:
        return {
          success: false,
          filename: '',
          content: '',
          mimeType: '',
          error: `Unknown format: ${options.format}`,
        };
    }
  } catch (error) {
    return {
      success: false,
      filename: '',
      content: '',
      mimeType: '',
      error: error instanceof Error ? error.message : 'Export failed',
    };
  }
}

/**
 * Trigger download of export result
 */
export function downloadExport(result: ExportResult): void {
  if (!result.success) {
    console.error('Cannot download failed export:', result.error);
    return;
  }
  
  const blob = result.content instanceof Blob 
    ? result.content 
    : new Blob([result.content], { type: result.mimeType });
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = result.filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Export and download a widget in one step
 */
export async function exportAndDownload(
  draft: DraftWidget,
  options: ExportOptions = { format: 'html' }
): Promise<boolean> {
  const result = await exportWidget(draft, options);
  if (result.success) {
    downloadExport(result);
    return true;
  }
  return false;
}

export default {
  exportWidget,
  downloadExport,
  exportAndDownload,
};

